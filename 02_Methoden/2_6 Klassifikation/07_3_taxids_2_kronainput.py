#!/usr/bin/env python
import argparse
#import re
import sys
import os

parser=argparse.ArgumentParser(description = "Turn blast2lca output into input for KRONA. IMPORTANT: only works for blast2lca-output generated with the \"-tid\" argument!")
parser.add_argument('-i', '--input', action = "store", dest = "input", required = True, help = "Table generated by blast2lca (USING THE \"-tid\" argument!)")
parser.add_argument("-c", "--coverage", action = "store", dest = "coverage_file", help = "Table with coverages produced wich bamm parse")
parser.add_argument('-o', '--output', action = "store", dest = "output", default = "KRONA_input", help = "Basename for output-files (that shall be input for KRONAs \"ktImportTaxonomy\"")
parser.add_argument('--raw_diamond', action = "store_true", dest = "raw_diamond", default = False, help = "Indicate if blast input table has contig names in raw diamond blast output (Orf number appended to contigname) default = False")
args = parser.parse_args()

header = "#Name\t#TaxID#Score#Magnitude\n"
##get contig lengths to use as magnitudes using regex
#pA = re.compile("_length_\d+_")
#pB = re.compile("\d+")

def read_coverage(coverage_file):
	sys.stderr.write("\nreading coverage file\n")
	counter = 0
	coverage_dict = {}
	infile = open(coverage_file, "r")
	firstline = True
	for line in infile:
		#print line
		linetokens = line.strip().split("\t")
		if firstline:
			headers = linetokens[2:]
			coverage_dict["headers"] = headers
			firstline = False
			continue
		contig = linetokens[0]
		coverage_dict[contig] = {}
		coverages = linetokens[2:]
		for hi in range(len(headers)):
			coverage_dict[contig][headers[hi]] = coverages[hi]
		counter += 1
		if counter % 1000 == 0:
			sys.stderr.write("\r read {} lines".format(counter))
	sys.stderr.write("\r read {} lines".format(counter))
	#print coverage_dict
	return coverage_dict
		

def write_withcovmag(inputfile, output_basename, coverage_dict):
	sys.stderr.write("\nreading input file and writing output\n")
	sys.stderr.write("\noutputfiles : {}\n".format(coverage_dict["headers"]))
	writecounter, skipcounter = 0, 0
	infile = open(inputfile, "r")
	outfiles = [ open("{}_{}.tab".format(output_basename, os.path.basename(h)), "w") for h in coverage_dict["headers"] ]
	for outfile in outfiles:
		outfile.write(header)
	for line in infile:
		tokens = line.split() #split lines into columns based on semicolons
		#print tokens
		if args.raw_diamond:
			protein = tokens[0]
			cut_pos = protein.rfind("_") # with prodigal output, proteins are named after the contigs with a "_" and a gene-number appended to the right
			contig = protein[0:cut_pos]
			#print contig
		else:
			contig = tokens[0] #take first value as contigname
		if contig not in coverage_dict:
			print "have not found {} in coverage dict".format(contig)
			#print line
			skipcounter += 1
			continue
		taxid = tokens[1] #take the second column as taxid
		score = tokens[-2]
		if contig == taxid or (args.raw_diamond and protein == taxid): #if there IS no "third value from the right" just give taxid=0 (="unclassified")
			taxid = "0"
			score = "0"
		#uncomment the following TWO lines IF ranks are shown for each Tid (or comment them if otherwise)
		#else: #otherwise remove the rank-information and only take the actual taxid-number
			#print taxid
		#	taxid = taxid.split("__")[1]
		for hi in range(len(coverage_dict["headers"])):
			hname = coverage_dict["headers"][hi]
			mag = coverage_dict[contig][hname]
			if args.raw_diamond:
				outline = "{}\t{}\t{}\n".format(protein, taxid, mag)
			else:
				outline = "{}\t{}\t{}\n".format(contig, taxid, mag)
			outfiles[hi].write(outline)
		writecounter += 1
		if writecounter % 1000 == 0:
			sys.stderr.write("\rwrote {} contigs. skipped {}".format(writecounter, skipcounter))
	infile.close()
	sys.stderr.write("\rwrote {} contigs. skipped {} \n".format(writecounter, skipcounter))
	for outfile in outfiles:
		outfile.close()
	

def old_write():
	inputfile=args.input
	outputfile=args.output
	infile = open(inputfile, "r")
	outfile = open(outputfile + ".tab", "w")
	outfile.write(header)
	for line in infile:
		tokens = line.split(";") #split lines into columns based on semicolons
		if args.raw_diamond: # with prodigal output, proteins are named after the contigs with a "_" and a gene-number appended to the right
			protein = tokens[0]
			cut_pos = protein.rfind("_") # with prodigal output, proteins are named after the contigs with a "_" and a gene-number appended to the right
			contig = protein[0:cut_pos]
		else:
			contig = tokens[0] #take first value as contigname
		taxid = tokens[-3] #take the third value from the right as taxid
		score = tokens[-2]
		#mag = pB.findall(pA.findall(contig)[0])[0]
		if contig == taxid: #if there IS no "third value from the right" just give taxid=0 (="unclassified")
			taxid = "0"
			score = "0"
			#print contig
		#uncomment the following TWO lines IF ranks are shown for each Tid (or comment them if otherwise)
		else: #otherwise remove the rank-information and only take the actual taxid-number
			taxid = taxid.split("__")[1]
		outfile.write("{}\t{}\t{}\n".format(contig, taxid, score))
		#outfile.write("{}\t{}\t{}\t{}\n".format(contig, taxid, score, mag)) #replace previous line with THIS line, if contig_lengths in contig_headers should be used as magnitudes
	infile.close()
	outfile.close()

def main():
	if args.coverage_file:
		coverage_dict = read_coverage(args.coverage_file)
		write_withcovmag(args.input, args.output, coverage_dict)
	else:
		sys.stderr.write("\nno coverage given, will output will be produced without magnitude values\n")
		old_write()

	print("\nFINISHED!\nnow create KRONA charts using this command:")
	print("ktImportTaxonomy -o <myoutputname.html> {}_<xxx>.tab".format(args.output))

main()
